<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[实现HTTPS通讯(TcpServer与SslStream)]]></title>
    <url>%2F%E5%AE%9E%E7%8E%B0https%E9%80%9A%E8%AE%AF-tcpserver%E4%B8%8Esslstream.html</url>
    <content type="text"></content>
      <categories>
        <category>学习笔记</category>
        <category>开发语言</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于https协议的TcpServer]]></title>
    <url>%2F%E5%9F%BA%E4%BA%8Ehttps%E5%8D%8F%E8%AE%AE%E7%9A%84tcpserver.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[雪花算法]]></title>
    <url>%2F%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[RESTful接口版本管理]]></title>
    <url>%2Frestful%E6%8E%A5%E5%8F%A3%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86.html</url>
    <content type="text"><![CDATA[REST简介REST，全称是Representational State Transfer，译为表现层状态转化。REST并不是一个标准，而是一种软件架构风格。 在REST风格下，客户端通过url访问网络上的一个资源，通过HTTP动词请求服务端对资源进行操作。 接口版本服务端接口是会不断变化更新的，一个好的设计，是提供不同版本的接口，而不是在一个接口上进行修改。部署时，服务端包含不同版本的接口，客户端可以依旧使用老版本的接口，也可以随服务端升级到新版本。当所有客户端都升级到新版本时，服务端可以考虑移除旧版本的接口。 在REST风格下，我们可以通过对接口增加版本号的概念，去区分不同版本的接口。版本号有两种表现形式，一种是包含在url中，一种是包含在HTTP头中。例如： url123http://somewhere.com/xxx/v1/userAccept: application/json; version=v1 Spring Boot starter源码接口版本管理源码 实现思路Spring Boot提供了starter的标准，starter完成自动配置，开发者只需要引用starter，就可以实现功能。我们可以通过开发一个api-version-spring-boot-starter，帮助应用快速实现接口版本管理。 Spring Boot对于自定义starter提出的指导有以下几点： 项目包含两个模块，一个是autoconfigure，一个是starter autoconfigure模块包含自动配置相关的代码，和一个清单文件，清单文件中包含自动加载bean的class名 starter需引用autoconfigure模块和其他必要的依赖 因此，我们定义了两个模块，一个是autoconfigure，一个是starter，在autoconfigure中完成接口版本管理的功能和自动配置，实现在url中标明版本号。 ApiVersion注解首先，定义一个注解，注解的作用是标识controller的版本ApiVersion.java12345678910111213141516171819@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface ApiVersion &#123; /** * 版本号 * * @return 版本号 */ @AliasFor("value") String version() default ""; /** * 版本号 * * @return 版本号 */ @AliasFor("version") String value() default "";&#125; 扩展RequestMappingHandlerMappingRequestMappingHandlerMapping提供了url-controller方法间映射的能力，可以理解为在启动阶段，Spring扫描标注了@Controller注解的类，对其中标注了@RequestMapping注解的方法进行注册，key为@RequestMaping指定的url，value为方法。@Controller注解的变体有@RestController，@RequestMapping注解的变体有@GetMapping、@PostMapping等。当客户端发起请求时，DispatcherServlet在分发请求时，根据启动阶段注册的url和方法映射进行分发。 因此我们需要扩展两个类，一个是RequestMappingHandlerMapping，在注册url时，将url注册为统配符的形式，如{version}/user。另外一个是RequestCondition，提供具体的匹配规则。 具体工作原理是： 服务端启动阶段，Spring扫描Controller，注册能力由ApiVersionUrlRequestMappingHandlerMapping提供，将标注了@ApiVersion注解的Controller，url统一注册为统配符的形式，形如{version}/user，同时将定义的版本号也作为url的属性，注册到Spring容器中 客户端发起请求，请求的url形如v1/user DispathcerServlet接受到请求，对请求的url与注册的url进行匹配。匹配规则由ApiVersionUrlRequestCondition提供，即注册url符合请求的url，且注册版本号与请求的版本号一致，即为匹配成功 ApiVersionUrlRequestCondition.java12345678910111213141516171819202122232425262728293031323334@NoArgsConstructorpublic class ApiVersionUrlRequestCondition implements RequestCondition&lt;ApiVersionUrlRequestCondition&gt;, ApplicationContextAware &#123; @Getter private String version; private static String regexFormat = ""; public ApiVersionUrlRequestCondition(String version) &#123; this.version = version; &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; if (regexFormat == null || regexFormat.length() == 0) &#123; ApiVersionProperties apiVersionProperties = applicationContext.getBean(ApiVersionProperties.class); ServerProperties serverProperties = applicationContext.getBean(ServerProperties.class); if (serverProperties.getServlet().getContextPath() != null) &#123; regexFormat = serverProperties.getServlet().getContextPath(); &#125; regexFormat += "/" + apiVersionProperties.getPrefix() + "%s/**"; &#125; &#125; @Override public ApiVersionUrlRequestCondition combine(ApiVersionUrlRequestCondition other) &#123; return new ApiVersionUrlRequestCondition(other.getVersion()); &#125; @Override public ApiVersionUrlRequestCondition getMatchingCondition(HttpServletRequest request) &#123; PathMatcher pathMatcher = new AntPathMatcher(); boolean match = pathMatcher.match(String.format(regexFormat, version), request.getRequestURI()); return match ? this : null; &#125; @Override public int compareTo(ApiVersionUrlRequestCondition other, HttpServletRequest request) &#123; return other.getVersion().compareTo(this.version); &#125;&#125; ApiVersionUrlRequestMappingHandlerMapping.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Slf4jpublic class ApiVersionUrlRequestMappingHandlerMapping extends RequestMappingHandlerMapping &#123; public static final String VERSION_PREFIX = "/&#123;version&#125;"; public static final String PATH_KEY = "path"; public static final String VALUE_CACHE_KEY = "valueCache"; @Override protected RequestCondition&lt;ApiVersionUrlRequestCondition&gt; getCustomTypeCondition(Class&lt;?&gt; handlerType) &#123; ApiVersion apiVersion = AnnotationUtils.findAnnotation(handlerType, ApiVersion.class); return createCondition(apiVersion); &#125; @Override protected RequestCondition&lt;ApiVersionUrlRequestCondition&gt; getCustomMethodCondition(Method method) &#123; ApiVersion apiVersion = AnnotationUtils.findAnnotation(method, ApiVersion.class); return createCondition(apiVersion); &#125; @Override protected RequestMappingInfo getMappingForMethod(Method method, Class&lt;?&gt; handlerType) &#123; RequestMappingInfo info = createRequestMappingInfo(method); if (info != null) &#123; RequestMappingInfo typeInfo = createRequestMappingInfo(handlerType); if (typeInfo != null) &#123; info = typeInfo.combine(info); &#125; &#125; return info; &#125; @Nullable private RequestMappingInfo createRequestMappingInfo(AnnotatedElement element) &#123; RequestMapping requestMapping = AnnotatedElementUtils.findMergedAnnotation(element, RequestMapping.class); ApiVersion apiVersion = AnnotationUtils.findAnnotation(element, ApiVersion.class); if (apiVersion != null) &#123; InvocationHandler invocationHandler = Proxy.getInvocationHandler(requestMapping); Class&lt;? extends InvocationHandler&gt; clazz = invocationHandler.getClass(); try &#123; Field declaredField = clazz.getDeclaredField(VALUE_CACHE_KEY); declaredField.setAccessible(true); Map&lt;String, Object&gt; valueCache = (Map) declaredField.get(invocationHandler); String[] path = requestMapping.path(); if (path != null) &#123; for (int i = 0; i &lt; path.length; i++) &#123; path[i] = VERSION_PREFIX + path[i]; &#125; valueCache.put(PATH_KEY, path); declaredField.set(invocationHandler, valueCache); &#125; &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123; log.error("这是不可能发生的事。。", e); &#125; &#125; RequestCondition&lt;?&gt; condition = (element instanceof Class ? getCustomTypeCondition((Class&lt;?&gt;) element) : getCustomMethodCondition((Method) element)); return (requestMapping != null ? createRequestMappingInfo(requestMapping, condition) : null); &#125; private RequestCondition&lt;ApiVersionUrlRequestCondition&gt; createCondition(ApiVersion apiVersion) &#123; return apiVersion == null ? null : new ApiVersionUrlRequestCondition(apiVersion.version()); &#125;&#125; 配置RequestMappingHandlerMapping自定义了RequestMappingHandlerMapping后，我们需要注册自定义处理类，让Spring容器使用自定义处理类进行url注册。注册自定义处理类的方法非常简单，只需要扩展WebMvcRegistrations，覆写getRequestMappingHandlerMapping方法即可。 ApiVersionUrlWebConfig.java123456public class ApiVersionUrlWebConfig implements WebMvcRegistrations &#123; @Override public RequestMappingHandlerMapping getRequestMappingHandlerMapping() &#123; return new ApiVersionUrlRequestMappingHandlerMapping(); &#125;&#125; 配置版本号前缀考虑到有些人习惯将版本号定义为v1，有的人则习惯定义为1，我们还需要提供版本号前缀的配置项。 ApiVersionProperties.java12345678@Data@ConfigurationProperties(prefix = "api.version")public class ApiVersionProperties &#123; /** * 全局版本号前缀 */ private String prefix = "v";&#125; 自动配置Spring Boot starter的核心思想是自动配置，因此，我们需要注册以上所有的bean到Spring容器中。 自动配置类ApiVersionHttpConfiguration.java12345678910111213141516171819@Configuration@EnableConfigurationProperties@ConditionalOnWebApplicationpublic class ApiVersionHttpConfiguration &#123; @Bean public ApiVersionUrlWebConfig apiVersionUrlWebConfig() &#123; return new ApiVersionUrlWebConfig(); &#125; @ConditionalOnMissingBean @Bean public ApiVersionProperties apiVersionProperties() &#123; return new ApiVersionProperties(); &#125; @ConditionalOnMissingBean @Bean public ApiVersionUrlRequestCondition apiVersionUrlRequestCondition() &#123; return new ApiVersionUrlRequestCondition(); &#125;&#125; 配置清单Spring规定了清单文件的路径resources/META-IN/spring.factories，我们需要在清单文件中标注自动配置类的路径 spring.factories12org.springframework.boot.autoconfigure.EnableAutoConfiguration=\priv.ln.api.version.spring.boot.autoconfigure.ApiVersionHttpConfiguration 在Spring Boot项目中使用接口版本管理在pom.xml中添加依赖，引用starter。 在Controler中添加注解12345@ApiVersion("1")@Controller@RequestMapping("/xxx")public class XxxController&#123;&#125; 访问该接口时，通过url/v1/xxx访问]]></content>
      <categories>
        <category>工作笔记</category>
        <category>Java Web</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Java Web</tag>
        <tag>Spring Boot</tag>
        <tag>RESTful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机VirtualBox环境下Ubuntu存储扩容]]></title>
    <url>%2F%E8%99%9A%E6%8B%9F%E6%9C%BAvirtualbox%E7%8E%AF%E5%A2%83%E4%B8%8Bubuntu%E5%AD%98%E5%82%A8%E6%89%A9%E5%AE%B9.html</url>
    <content type="text"><![CDATA[之前我为虚拟机分配的存储太小了，鼓捣了半天终于明白怎么扩容了，下面记录一下。 确认VirtualBox中配置的存储类型我配置的是动态分配存储，以下经验也许只试用于动态分配存储。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Linux</category>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>virtualbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Log4j2内存占用高解决方案]]></title>
    <url>%2Flog4j2%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E9%AB%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html</url>
    <content type="text"><![CDATA[Log4j2异步日志回顾之前，我们在应用中使用Log4j2的异步日志，获得了很好的表现。 内存占用过高我们在生产环境使用了kubernetes技术，在应用部署到k8s后，监控了一段时间，发现每天都有内存溢出的现象。而当应用心跳地址多次无法访问后，k8s自动帮我们重启了应用，但是重启并不能从根本上解决问题。 在某一次，容器内存占用很高时，我们将内存使用情况dump下来，使用IBM的工具分析了一下，发现是Log4j2的某个类所使用的ConcurrentHashMap集合很大，占用内存很高，这时终于发现了问题原因。 问题分析过程首先，占用内存过高的类是RoutingAppender，现象是RoutingAppender类中使用的ConcurrentHashMap集合过大，先简单介绍一下RoutingAppdener。 RoutingAppender相当于一个路由器，分析每次写日志的操作，然后将它们路由到子Appender上。路由的依据是一个路由key，路由key需要预先配置，每次写日志时，RoutingAppender会计算路由key，如果配置了路由key对应的子Appender，那么就路由到子Appender上，由子Appender负责真正的日志输出。 我阅读了一下RoutingAppender的源码。RoutingAppender有两个变量是ConcurrentMap类型的： pom.xml12private final ConcurrentMap&lt;String, AppenderControl&gt; appenders = new ConcurrentHashMap&lt;&gt;();private final ConcurrentMap&lt;Object, Object&gt; scriptStaticVariables = new ConcurrentHashMap&lt;&gt;(); 其中，appenders变量存放的是子Appender，key是解析后的路由key。 可达鸭眉头一皱，发现事情并不简单。 之前，我们在使用异步日志时配置过RoutingAppender，现在回忆一下是如何配置的： RoutingAppender12345678910111213141516&lt;Routing name="routing"&gt; &lt;Routes pattern="$$&#123;ctxdefval:appid&#125;$$&#123;ctxdefval:userid&#125;$$&#123;date:yyyy-MM-dd&#125;"&gt; &lt;Route&gt; &lt;!-- 输出到日志文件 --&gt; &lt;RollingRandomAccessFile name="RollingFile" fileName="$&#123;ctxdefval:logpath&#125;/$&#123;ctxdefval:appid&#125;/$&#123;date:yyyy-MM-dd&#125;/$&#123;ctxdefval:userid&#125;.log" filePattern="$&#123;ctxdefval:logpath&#125;/$&#123;ctxdefval:appid&#125;/$&#123;date:yyyy-MM-dd&#125;/$&#123;ctxdefval:userid&#125;-%i.log.gz"&gt; &lt;PatternLayout pattern="%d&#123;HH:mm:ss.SSS&#125; [%-5level] [%tid.%tn] %msg %equals&#123;%x&#125;&#123;[]&#125;&#123;&#125;%xEx%n"/&gt; &lt;Policies&gt; &lt;!-- 日志达到50MB时打包 --&gt; &lt;SizeBasedTriggeringPolicy size="50 MB"/&gt; &lt;/Policies&gt; &lt;/RollingRandomAccessFile&gt; &lt;/Route&gt; &lt;/Routes&gt;&lt;/Routing&gt; 可以看到，我们配置的路由key规则是一个表达式（如下），RoutingAppender在工作时，会解析这个表达式，比如当前上下文中，应用id是app，userid是user，日期是2019-01-12，解析后的路由key就是appuser2019-01-12。这时，会将子Appender存放到map中，key是解析后的路由key。我们可以预想一下，随着时间的增长，这个map会越来越大。 路由key规则1$$&#123;ctxdefval:appid&#125;$$&#123;ctxdefval:userid&#125;$$&#123;date:yyyy-MM-dd&#125; 那么问题应该就出现在这里啦。 解决办法我想到的解决办法，就是定期清理这个map了。所以我继续阅读源码，发现了一个根据路由key清理map的方法，查找调用这个方法的类，惊讶的发现log4j已经为我们提供了清理插件。 清理插件是IdlePurgePolicy，具体的实现细节就直接阅读源码吧，或者看javadoc，说的很清楚了，可以配置的参数如下： 参数名 描述 timeToLive appender闲置时间，超过这个闲置时间就会被移除 checkInterval 检查的时间间隔，与timeToLive相乘就是真正的清理周期。不配置的话，清理周期就是timeToLive的值 timeUnit 时间单位，可选的配置项需参考枚举类TimeUnit 插件需要配置到Routing节点下，我配置的是10分钟清理一次： log4j2.xml1&lt;IdlePurgePolicy timeToLive="10" timeUnit="minutes"/&gt;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>开发框架</category>
        <category>Log4j</category>
        <category>Log4j2</category>
      </categories>
      <tags>
        <tag>Log4j</tag>
        <tag>Log4j2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[guacamole插件开发]]></title>
    <url>%2Fguacamole%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91.html</url>
    <content type="text"><![CDATA[Guacamole手册：Guacamole手册 Guacamole是什么？ Apache Guacamole是一个无客户端的远程桌面网关。 它支持VNC，RDP和SSH等标准协议。 我们称之为无客户端，因为不需要插件或客户端软件。 感谢HTML5，一旦Guacamole安装在服务器上，您访问桌面所需的只是一个Web浏览器。 为什么要用Guacamole？ 随时随地访问PC 保持桌面在云端 免费、开源 建立在文档齐全的API之上 商业支持 GuacamoleApache Guacamole Guacamole架构Guacamole架构下，发起一次远程桌面请求的流程是： 用户使用Web浏览器，访问Guacamole客户端应用，使用Guacamole协议请求一个远程桌面 Guacamole客户端应用将Guacamole协议转发给guacd服务端 guacd服务端解释Guacamole协议，转换成远程桌面支持的协议后，请求到真实的远程桌面 Guacamole协议Guacamole协议，是一种用于远程显示渲染和事件传输的协议。Guacamole协议不同于远程桌面协议（VNC或RDP等），它建立在远程桌面协议之上，旨在提供跨平台的远程桌面功能，不依赖于特定的桌面环境。由一个中间件，将Guacamole协议翻译成具体的远程桌面协议。当新增一个远程桌面协议时，只需要在中间件上加入新的翻译转换策略，而不需要修改客户端应用。 guacdguacd是Guacamole的核心，它动态加载对远程桌面协议（称为“客户端插件”）的支持，并根据从Web应用程序收到的指令将它们连接到远程桌面吗，也就是上文提到的翻译中间件。 guacd是一个守护进程，它与Guacamole一起安装并在后台运行，侦听来自Web应用程序的TCP连接。 guacd也不了解任何特定的远程桌面协议，而是实现了足够的Guacamole协议来确定需要加载哪些协议支持以及必须将哪些参数传递给它。 加载客户端插件后，它将独立于guacd运行，并完全控制自身与Web应用程序之间的通信，直到客户端插件终止。 guacd和所有客户端插件依赖于一个公共库libguac，它使通过Guacamole协议的通信更容易，更抽象。 Gucamole客户端应用用户实际使用的Guacamole部分是Web应用程序。Web应用程序不实现任何远程桌面协议。 它依赖于guacd，只需要实现一个漂亮的Web界面和身份验证层。 安装guacd官方提供两种安装方式，一种是下载源码，手动编译安装；一种是docker镜像。 官方文档上由详细说明： 编译安装 docker镜像 guacamole插件开发Guacamole的插件可以： 提供备用身份验证方法和连接/用户数据源。 提供将在Guacamole执行身份验证和隧道连接等任务时通知的事件侦听器。 通过额外的CSS文件和静态资源个性化Guacamole。 通过提供将自动加载的JavaScript来扩展Guacamole的JavaScript代码。 添加其他显示语言，或更改现有语言的翻译字符串。 guacamole插件加载方式Guacamole客户端应用是与插件是分离部署的，客户端应用在启动阶段，动态加载插件。因此需要理解插件的加载方式，才能开发出符合自身需求的插件。 因为应用与插件是分离部署的，所以Guacamole约定了一个配置路径，用于存放资源文件，其中就包括插件。客户端应用在启动时，到配置路径下查找是否有插件，如果有，则加载到应用中。 guacamole配置路径guacamole配置路径称为GUACAMOLE_HOME，默认情况下位于/etc/guacamole。所有配置文件，插件等都存放在此目录中。 GUACAMOLE_HOME的结构是严格定义的，由以下可选文件组成： guacamole.propertiesGuacamole的主配置文件。此文件中的属性指示Guacamole将如何连接到guacd，并可能配置已安装的身份验证扩展的行为。 logback.xmlGuacamole使用的日志框架是Logback。默认情况下，Guacamole只将日志输出到控制台。可以通过提供该文件自定义日志输出行为。 extensions/插件存放目录，Guacamole会在启动时自动加载此目录中的所有.jar文件。 lib/插件依赖jar包存放目录。如果插件依赖第三方jar，例如数据库驱动程序，就可以放在这个目录下。 插件格式插件是一个.jar文件，jar中包含类、资源和guacamole扩展清单。其中，扩展清单是插件的描述文件，需要放在jar文件的根目录下。Guacamole客户端应用启动时，读取扩展清单，来进行动态加载插件。 扩展清单扩展清单是一个json文件，文件名约定为guac-mainfest.json。如果你和我一样，基于maven开发，那么根据maven对资源文件的约定，扩展清单需要放在resouces文件夹下。扩展清单是一个配置文件，配置项如下： 属性 是否必填 描述 guacamoleVersion 是 插件依赖的guacamole版本号，如果插件不依赖于特定版本，则可以使用*，将绕过版本兼容性检查。 name 是 易于阅读、理解的名字 namespace 是 插件的唯一标识。如果插件中包含静态资源，那么这些资源将以该命名空间作为上下文根。 authProviders 否 一组限定类名，这些类是AuthenticationProvider的子类，插件中提供的用于身份验证的类。 listeners 否 一组限定类名，这些类是Listener的子类，插件中提供的用于监听事件的类。 js 否 一组JavaScript文件路径，路径必须是相对路径。 css 否 一组CSS文件路径，路径必须是相对路径。 html 否 一组HTML文件路径，路径必须是相对路径。 translations 是 一组翻译文件路径，路径必须是相对路径。此处声明的翻译文件将自动添加到可用语言中,如果翻译文件提供Guacamole中已存在的语言，则其字符串将覆盖现有翻译的字符串 resources 否 一个对象，其中每个属性名称是Web资源文件的名称，每个值都是该资源的mimetype，所有路径都必须是相对路径。此处声明的Web资源将在app/ext/NAMESPACE/PATH中提供给应用程序，其中NAMESPACE是namespace属性的值，PATH是声明的Web资源文件名。 最简单的扩展清单12345&#123; "guacamoleVersion" : "0.9.14", "name" : "My Extension", "namespace" : "my-extension"&#125; 扩展清单123456789101112&#123; "guacamoleVersion" : "0.9.14", "name" : "My Extension", "namespace" : "my-extension", "css" : [ "theme.css" ], "html" : [ "loginDisclaimer.html" ], "resources" : &#123; "images/logo.png" : "image/png", "images/cancel.png" : "image/png", "images/delete.png" : "image/png" &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>开发框架</category>
        <category>Guacamole</category>
      </categories>
      <tags>
        <tag>guacamole</tag>
        <tag>guacamole extensions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Log4j2异步日志]]></title>
    <url>%2Flog4j2%E5%BC%82%E6%AD%A5%E6%97%A5%E5%BF%97.html</url>
    <content type="text"><![CDATA[Log4j 2的异步日志详细介绍：Async Loggers Apache Log4j 2是对Log4j的升级，它比其前身Log4j 1.x提供了重大改进，并提供了Logback中可用的许多改进，同时修复了Logback架构中的一些固有问题。 Log4jApache Log4j 2 Log4j 2基于LMAX Disruptor库，实现了一个高性能的异步记录器。在多线程场景中，异步记录器的吞吐量比Log4j 1.x和Logback高18倍，延迟低。 项目中引入Log4j2依赖我创建的是Maven项目，按需要在pom文件中添加如下依赖：pom.xml123456789101112131415161718192021222324252627282930&lt;!-- Log4j2 API接口 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j2.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Log4j2 API实现 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j2.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Log4j2 web项目支持 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-web&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j2.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Apache Commons Logging桥接适配器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-jcl&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j2.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--SLF4J桥接适配器--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j2.version&#125;&lt;/version&gt;&lt;/dependency&gt; 异步日志异步日志介绍异步日志的实现思路是在单独的线程中执行I/O操作，在调用形如Logger.log的API时，能够更快的返回到主程序中，以提高应用程序的性能。Log4j 2在异步日志领域，做了很多优化和改进。而我们只需要在配置文件中，做一个简单的配置，就可以获得异步日志记录的功能特性。 Log4j 2设计了两种异步日志： Async Appender。内部使用的一个队列（ArrayBlockingQueue）和一个后台线程，日志先存入队列，后台线程从队列中取出日志。阻塞队列容易受到锁竞争的影响，当更多线程同时记录时性能可能会变差。 Async Logger。内部使用的是LMAX Disruptor技术，Disruptor是一个无锁的线程间通信库，它不是一个队列，不需要排队，从而产生更高的吞吐量和更低的延迟。 我们采用第二种，也是官方推荐的Async Logger的方式，进行异步日志的配置。 异步日志配置项目中引入Disruptor依赖因为Async Logger使用了Disruptor技术，需要在pom文件中添加如下依赖：pom.xml12345678910111213&lt;!-- Disruptor --&gt;&lt;dependency&gt; &lt;groupId&gt;com.lmax&lt;/groupId&gt; &lt;artifactId&gt;disruptor&lt;/artifactId&gt; &lt;version&gt;3.3.7&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 如果你想使用Async Appender，可以考虑引入这个包替代ArrayBlockingQueue --&gt;&lt;dependency&gt; &lt;groupId&gt;com.conversantmedia&lt;/groupId&gt; &lt;artifactId&gt;disruptor&lt;/artifactId&gt; &lt;classifier&gt;jdk7&lt;/classifier&gt; &lt;version&gt;1.2.10&lt;/version&gt;&lt;/dependency&gt; 注意，Log4j-2.9+需要disruptor-3.3.4.jar或更高版本。在Log4j-2.9之前，需要disruptor-3.0.0.jar或更高版本。 全异步设置一个环境变量，用来开启全异步： 全异步1log4j2.contextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector 开启全异步时，日志配置中需要使用普通的Root和Logger元素。如果使用了AsyncRoot或AsyncLogger，将产生不必要的开销。 同步异步混合全异步是官方推荐的，也是性能最佳的方式，但同步异步混合使用，能够提供更大的灵活性。使用AsyncRoot、AsyncLogger、Root、Logger混合配置，可以实现同步异步混合。但是需要注意，配置中只能有一个root元素，也就是只能使用AsyncRoot或Root中的一个。 实际配置自定义插件Log4j使用插件模式配置组件。因此，无需编写代码来创建和配置Appender，Layout，Pattern Converter等，Log4j自动识别并使用插件。 因此，我们可以基于插件模式，方便的扩展现有功能特性。 我有两个需求： 日志文件做分包处理，按照”应用编码/用户标识/8位年月日.log”的规则细化。其中应用编码和用户标识，在应用启动阶段，是空的，而应用启动阶段是需要输出日志的。因此，我希望在应用编码和用户标识为空时，log4j能识别到这种情况，并给它们赋一个默认值。 日志文件的根路径是可配的，但是我又不希望可配置的参数分散到不同的配置文件中，所以希望日志根路径能够到其他配置文件中读取。 为实现以上需求，我编写了一个自定义插件，基于Log4j提供的上下文解析插件，进行了扩展： ContextMapWithDefValLookup1234567891011121314151617181920@Plugin(name = "ctxdefval", category = "Lookup")public class ContextMapWithDefValLookup extends ContextMapLookup &#123; public static final String DEFAULT_VALUE_PREFIX = "no"; @Override public String lookup(String key) &#123; return this.lookupWithDefaultValue(key, super.lookup(key)); &#125; @Override public String lookup(LogEvent event, String key) &#123; return this.lookupWithDefaultValue(key, super.lookup(event, key)); &#125; private String lookupWithDefaultValue(String key, String value) &#123; // 上下文中没有该字段的情况 if (StringUtils.isEmpty(value)) &#123; // 从统一配置文件中获取，如果获取不到，使用no+key作为默认值（noappid) value = ReadProperty.getPlatString(key, DEFAULT_VALUE_PREFIX + key); &#125; return value; &#125;&#125; 配置文件log4j2.xml12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;Configuration status="debug" packages="com.yondervision.plat.common.log.lookup"&gt; &lt;Appenders&gt; &lt;!--打印日志到控制台--&gt; &lt;Console name="stdout" target="SYSTEM_OUT"&gt; &lt;PatternLayout pattern="%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %-5level %msg %equals&#123;%x&#125;&#123;[]&#125;&#123;&#125;%xEx%n"/&gt; &lt;/Console&gt; &lt;Routing name="routing"&gt; &lt;Routes pattern="$$&#123;ctxdefval:appid&#125;$$&#123;ctxdefval:userid&#125;$$&#123;date:yyyy-MM-dd&#125;"&gt; &lt;Route&gt; &lt;!-- 输出到日志文件 --&gt; &lt;RollingRandomAccessFile name="RollingFile" fileName="$&#123;ctxdefval:logpath&#125;/$&#123;ctxdefval:appid&#125;/$&#123;date:yyyy-MM-dd&#125;/$&#123;ctxdefval:userid&#125;.log" filePattern="$&#123;ctxdefval:logpath&#125;/$&#123;ctxdefval:appid&#125;/$&#123;date:yyyy-MM-dd&#125;/$&#123;ctxdefval:userid&#125;-%i.log.gz"&gt; &lt;PatternLayout pattern="%d&#123;HH:mm:ss.SSS&#125; [%-5level] [%tid.%tn] %msg %equals&#123;%x&#125;&#123;[]&#125;&#123;&#125;%xEx%n"/&gt; &lt;Policies&gt; &lt;!-- 日志达到50MB时打包 --&gt; &lt;SizeBasedTriggeringPolicy size="50 MB"/&gt; &lt;/Policies&gt; &lt;/RollingRandomAccessFile&gt; &lt;/Route&gt; &lt;/Routes&gt; &lt;/Routing&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;AsyncRoot level="debug"&gt; &lt;AppenderRef ref="stdout" level="debug"/&gt; &lt;AppenderRef ref="routing" level="info"/&gt; &lt;/AsyncRoot&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; 说明： 如果Layout中配置成与%C or $class, %F or %file, %l or %location, %L or %line, %M or %method中的一个位置相关的属性，Log4j 2将获取堆栈的快照，并遍历堆栈跟踪以查找位置信息。这是一项昂贵的操作，同步日志中，在获取此堆栈快照时可能会长时间等待。如果不需要位置，则不会获取快照。而异步日志需要在将日志消息传递给另一个线程之前做出此决定，在该点之后，位置信息将丢失。对于异步日志来说，获取堆栈跟踪快照的性能影响甚至更高。因此，默认情况下，异步记录器和异步追加器不包含位置信息。可以通过指定includeLocation =“true”来覆盖异步日志的默认行为。 RollingRandomAccessFileAppender类似于标准的RollingFileAppender，内部使用的是ByteBuffer和RandomAccessFile。由于RandomAccessFile可以自由访问文件的任意位置，日志记录通常是向已存在的文件后追加内容，所以使用RandomAccessFile能获得更好的性能。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>开发框架</category>
        <category>Log4j</category>
        <category>Log4j2</category>
      </categories>
      <tags>
        <tag>Log4j</tag>
        <tag>Log4j2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security动态配置]]></title>
    <url>%2Fspring-security%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[我们在开发Web应用时，通常希望保护某些资源（页面或数据），对这些资源做安全控制，比如：未登录的用户访问资源时，自动跳转至登录页面；拥有管理员身份的用户，可以访问某些管理界面。 本文介绍一种基于Spring Security的动态配置权限的方法，使用的是JavaConfig的方式。 Spring Security是一个功能强大且可高度自定义的身份验证和访问控制框架。具有以下特性： 对身份验证和授权的全面和可扩展的支持 防止会话固定，点击劫持，跨站点请求伪造等攻击 Servlet API集成 可选与Spring Web MVC集成 还有很多啊.. SpringSpring Security 项目中引入Spring Security依赖我创建的是Maven项目，在pom文件中添加如下依赖：pom.xml123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-security.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-security.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-security.version&#125;&lt;/version&gt;&lt;/dependency&gt; 在web应用中启用Spring SecurityServlet3.0+如果应用部署在支持Servlet3.0+环境下，可以使用AbstractSecurityWebApplicationInitializer启用Spring Security，代码清单如下： Spring环境下启用Spring Security12public class SecurityWebApplicationInitializer extends AbstractSecurityWebApplicationInitializer &#123;&#125; 非Spring环境下启用Spring Security12345public class SecurityWebApplicationInitializer extends AbstractSecurityWebApplicationInitializer &#123; public SecurityWebApplicationInitializer() &#123; super(SecurityConfig.class); &#125;&#125; 以上，可以理解为，Spring自动注册了某些filter。 Servlet2.5一些主流的中间件，仅支持Servlet2.5，比如WebLogic、Web Sphere。如果应用需要部署在这些中间件下，则不能使用以上方式，需要在web.xml中自行配置filter。代码清单如下：web.xml配置123456789&lt;filter&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 基于Spring Security进行安全配置启用Spring Security配置首先创建一个继承WebSecurityConfigurerAdapter抽象类的类，这样就获得了Spring Security提供的默认配置。然后使用@Configuration注解使这个类成为Spring的一个配置类，Spring启动时会读取类中的配置。最后使用@EnableWebSecurity注解启用Spring Security。 WebSecurityConfigurerAdapter抽象类，提供了一个方便的、开箱即用的Spring Security配置。该配置创建一个名为springSecurityFilterChain的Servlet过滤器，它负责应用程序中的所有安全性（保护应用程序URL，验证提交的用户名和密码，重定向到登录表单等）。想要实现自定义配置，只需要覆写相应的方法。 安全配置类1234@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;&#125; 接下来，将介绍Spring Security的具体配置，比如如何配置允许哪些用户登录，如何配置用户权限等。 具体配置实现自定义配置，需要覆写基类中的configure方法。configure1234@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; // TODO:这里写你的具体配置&#125; 登录配置假设你有如下需求： Web应用需要支持表单登录 登录界面或登录请求使用的是一个自定义的url 登录请求中，提交的用户名、密码字段名是自定义的 登录请求提交的参数中除用户名密码以外，还需要验证其他参数 自定义登录成功或失败的后续处理：比如登录成功时，先提示消息，再跳转到首页。 以下代码可以实现上述需求： 登录配置12345http.formLogin() .loginPage("/login").loginProcessingUrl("/system/login.&#123;ext&#125;") .usernameParameter("user_id").passwordParameter("user_password") .authenticationDetailsSource(new GetIpWebAuthenticationDetailsSource()) .successHandler(new SupportAjaxAuthSuccessHandler()).failureHandler(new SupportAjaxAuthFailHandler(); 接下来，详细说明每行配置的作用。 formLoginformLogin方法告知Spring Security开启表单登录，即以一种用户名密码登录的方式。 loginPage和loginProcessingUrlloginPage指定登陆页面的url是/login，这个配置的作用是当用户未登录时，请求将重定向到该url上，现象是跳转回登录页面。 loginProcessingUrl指定登录请求的url是/system/login.{ext}，可以通过Ajax的方式将用户名和密码提交到该url上，即一次登录请求。注意，Spring Security默认登录请求是POST类型。登录请求1234$.ajax(&#123; url : "/system/login.json", type : "POST"&#125;); 以上两个url中，都可以使用通配符，比如我使用的”{ext}，也就是说，可以url可以是/system/login.json或/system/login.xml，Spring Security会处理符合这个url的所有请求。 usernameParameter和passwordParameter指定登录请求中，提交的用户名、密码字段名分别是user_id和user_password。登录请求12345678$.ajax(&#123; url : "/system/login.json", type : "POST", data : &#123; 'user_id': userName, 'user_password' : password &#125;&#125;); authenticationDetailsSource使用一个自定义的AuthenticationDetailsSource，指定登录请求中，获取哪些数据作为凭证，供验证器验证。 Spring Security通过WebAuthenticationDetails类，记录web请求的客户端ip地址和sessionId。它在获取IP地址时，只是简单的调用了HttpServletRequest的getRemoteAddr方法，在集群环境下，这样获取不能获取到客户端的真实IP，因此我覆写了获取客户端ip地址部分代码，代码清单如下：GetIpWebAuthenticationDetailsSource12345678public class GetIpWebAuthenticationDetailsSource extends WebAuthenticationDetailsSource &#123; public GetIpWebAuthenticationDetailsSource() &#123; &#125; public WebAuthenticationDetails buildDetails(HttpServletRequest context) &#123; // 根据请求内容 构造本次请求的详细信息 return new GetIpWebAuthenticationDetails(context); &#125;&#125; GetIpWebAuthenticationDetails123456789101112public class GetIpWebAuthenticationDetails extends WebAuthenticationDetails &#123; private final String remoteAddress; public GetIpWebAuthenticationDetails(HttpServletRequest request) &#123; super(request); // 重新获取客户端地址 this.remoteAddress = ServletUtil.getIpAddr(request); &#125; @Override public String getRemoteAddress() &#123; return this.remoteAddress; &#125;&#125; 还可以在自定义的WebAuthenticationDetails实现类中，添加更多的属性，用来记录需要验证的参数 successHandler和failureHandlersuccessHandler方法指定了登录成功处理器，这里我返回了一个登陆成功的提示信息，同时将用户信息存入session中。failureHandler方法指定了登录失败处理器，这里我返回了一个登录失败的具体的提示信息，比如用户不存在、密码错误。实际上是不推荐这样做，提示信息应该是用户名或密码错误。successHandler123456789101112public class SupportAjaxAuthSuccessHandler extends SimpleUrlAuthenticationSuccessHandler &#123; private final static String RIGHT_CREDENTIALS = "rightCredentials"; @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; // 直接返回成功信息 SecurityHandlerUtil.successResponse(response, RIGHT_CREDENTIALS); UserContext user = new UserContext(); user.setOperId(authentication.getName()); // 用户信息存入session request.getSession().setAttribute("user", user); &#125;&#125; failureHandler123456789101112131415public class SupportAjaxAuthFailHandler extends SimpleUrlAuthenticationFailureHandler &#123; private static final String NOT_FOUND = "notFound"; private static final String BAD_CREDENTIALS = "badCredentials"; @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123; // 直接返回错误信息 if (exception instanceof UsernameNotFoundException) &#123; SecurityHandlerUtil.errorResponse(response, NOT_FOUND); &#125; else if (exception instanceof BadIpAuthenticationException) &#123; SecurityHandlerUtil.errorResponse(response, exception); &#125; else &#123; SecurityHandlerUtil.errorResponse(response, BAD_CREDENTIALS); &#125; &#125;&#125; 登录数据源配置一般来说，用户都是存在表中，Spring Security提供了多种数据源，开箱即用。这里我通过扩展DaoAuthenticationProvider，获取基类的所有功能，并新增了一个IP白名单的功能，只有IP白名单内的客户端可以使用正确的用户名密码登录。此外，还需要指定从哪个表里查询，查询哪些字段等。为此，Spring Security规定了一个UserDetailsService接口，并提供了一系列开箱即用的实现类，而这里我使用了自己的实现类。 配置登录数据源时，需要覆写configure的另外一个重载方法，代码清单如下： 登录数据源配置123456789101112131415@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.authenticationProvider(authenticationProvider);&#125;@Beanprotected AuthenticationProvider authenticationProvider(UserDetailsService apiPlatUserService) &#123; IpAuthenticationProvider authenticationProvider = new IpAuthenticationProvider(); // 指定用户信息业务实现 authenticationProvider.setUserDetailsService(apiPlatUserService); // 指定密码加密方式 authenticationProvider.setPasswordEncoder(new Md5PasswordEncoder()); // 显示用户不存在异常 authenticationProvider.setHideUserNotFoundExceptions(false); return authenticationProvider;&#125; UserDetailsService实现类1234567891011121314151617181920@Service("apiPlatUserService")public class UserServiceImpl implements UserDetailsService &#123; @Autowired private BaseDao baseDao; private List&lt;GrantedAuthority&gt; authorities; @PostConstruct private void init() &#123; // 我的应用中没有角色的概念，因此默认为每个用户分配一个管理员角色 authorities = new ArrayList&lt;GrantedAuthority&gt;(); authorities.add(new SimpleGrantedAuthority("ROLE_ADMIN")); &#125; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; APP005 app005 = baseDao.selectOneBySql("APP005.selectByPrimaryKey", username, APP005.class); if (app005 != null) &#123; return new User(app005.getLoginid(), app005.getPassword(), authorities); &#125; throw new UsernameNotFoundException("用户" + username + "不存在"); &#125;&#125; IpAuthenticationProvider12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class IpAuthenticationProvider extends DaoAuthenticationProvider &#123; @Autowired private SecurityConfigCache securityConfigCache; /** * ip匹配器集合 */ private List&lt;IpAddressMatcher&gt; ipAddressMatchers; @PostConstruct private void init() &#123; // 获取安全配置缓存中的ip白名单 创建ip匹配器集合 String ipWhileList = securityConfigCache.getIpWhileList(); if (StringUtils.isNotEmpty(ipWhileList)) &#123; String[] ips = ipWhileList.split(SecurityConfigCache.SEPARATOR); ipAddressMatchers = new ArrayList&lt;IpAddressMatcher&gt;(ips.length); for (String ip : ips) &#123; IpAddressMatcher ipAddressMatcher = new IpAddressMatcher(ip); ipAddressMatchers.add(ipAddressMatcher); &#125; &#125; &#125; @Override protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException &#123; // 先校验IP if (ipAddressMatchers != null &amp;&amp; ipAddressMatchers.size() &gt; 0) &#123; Object details = authentication.getDetails(); if (details != null &amp;&amp; details instanceof WebAuthenticationDetails) &#123; WebAuthenticationDetails webAuthenticationDetails = (WebAuthenticationDetails) details; // 注意 这里将获得在GetIpWebAuthenticationDetails中重新获取的真实IP String remoteAddress = webAuthenticationDetails.getRemoteAddress(); boolean isValid = false; // 遍历ip匹配器集合 有一个匹配则通过 for (IpAddressMatcher ipAddressMatcher : ipAddressMatchers) &#123; if (ipAddressMatcher.matches(remoteAddress)) &#123; isValid = true; break; &#125; &#125; if (!isValid) &#123; throw new BadIpAuthenticationException(messages.getMessage("badIp", new String[]&#123;remoteAddress&#125;)); &#125; &#125; else &#123; logger.debug("请求附加信息中未获取到ip,咋回事儿呢..."); throw new BadIpAuthenticationException(messages.getMessage("nullIp")); &#125; &#125; // 校验用户名密码是否正确 super.additionalAuthenticationChecks(userDetails, authentication); &#125;&#125; 登出配置假设你有如下需求： Web应用需要支持登出 登出请求使用的是一个自定义的url 自定义登出成功或失败的后续处理：比如登出成功时，先提示消息，再跳转到登录页 以下代码可以实现上述需求： 登出配置123http.logout() .logoutUrl("/system/logout.&#123;ext&#125;") .logoutSuccessHandler(new SupportAjaxLogoutSuccessHandler()); 接下来，详细说明每行配置的作用。 logoutlogout方法告知Spring Security支持登出处理，登出时，Spring Security自动清除用户缓存并使session失效。 logoutUrllogoutUrl指定登出请求的url是/system/logout.{ext}，可以通过Ajax的方式请求该url上，即一次登出请求。注意，Spring Security默认登出请求是POST类型。登出请求1234$.ajax(&#123; url : "/system/logout.json", type : "POST"&#125;); 资源访问限制一般来说，web应用都会做角色-菜单配置，即拥有某身份的用户可以访问响应的资源。而这个配置，通常不是硬编码的，可能使在表中配置的，也可能是在配置文件中配置的。代码清单如下： 资源权限配置123456ExpressionUrlAuthorizationConfigurer&lt;HttpSecurity&gt;.ExpressionInterceptUrlRegistry authorizeRequests = http.authorizeRequests();// 获取资源-权限映射 权限使用Spring Security提供的安全表达式Map&lt;RequestMatcher, String&gt; requestConfigs = securityConfigCache.getRequestConfigs();for (Map.Entry&lt;RequestMatcher, String&gt; requestConfig : requestConfigs.entrySet()) &#123; authorizeRequests.requestMatchers(requestConfig.getKey()).access(requestConfig.getValue());&#125; 其中，securityConfigCache是一个由Spring管理的bean，缓存了表中的配置。在初始化该bean时，从表中查询角色-菜单配置，构造一个资源-权限映射。 自定义异常处理器自定义异常处理器123http.exceptionHandling() .accessDeniedHandler(new UnauthorizedAccessDeniedHandler()) .authenticationEntryPoint(new UnauthorizedEntryPoint()); accessDeniedHandleraccessDeniedHandler方法指定了拒绝请求处理器。也就是指定当用户无权限访问资源时，如何对请求做出响应。 请求大体分为两种，一种是请求页面，一种是请求数据。而对这两种请求的拒绝处理也是不一样的，请求页面时，需要将请求重定向到登录界面，提示用户登录；请求数据时，则返回一个错误信息，提示用户无权访问。代码清单如下： UnauthorizedAccessDeniedHandler123456789public class UnauthorizedAccessDeniedHandler implements AccessDeniedHandler &#123; protected final Logger LOGGER = LogManager.getLogger(getClass()); public static final String UNAUTHORIZED = "unauthorized"; @Override public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException exception) throws IOException, ServletException &#123; LOGGER.error("当前登录用户无权限访问", exception); SecurityHandlerUtil.handleAnyUnthorizedRequest(request, response, UNAUTHORIZED); &#125;&#125; SecurityHandlerUtil1234567891011121314151617181920212223242526272829303132333435363738@Componentpublic class SecurityHandlerUtil &#123; public static void handleAnyUnthorizedRequest(HttpServletRequest request, HttpServletResponse response, String errorCode) throws IOException &#123; // 请求为ajax的情况 返回错误信息 if (SecurityHandlerUtil.isAjaxRequest(request)) &#123; SecurityHandlerUtil.errorResponse(response, errorCode); &#125; else &#123; // 其他情况 跳转回登录页 response.sendRedirect(request.getContextPath() + SecurityConfig.LOGIN); &#125; &#125; public static boolean isAjaxRequest(HttpServletRequest request) &#123; String ajaxFlag = request.getHeader("X-Requested-With"); return ajaxFlag != null &amp;&amp; "XMLHttpRequest".equals(ajaxFlag); &#125; public static void errorResponse(HttpServletResponse response, String msgCode) throws IOException &#123; writeResponse(response, "9999", getMessage(msgCode)); &#125; public static void successResponse(HttpServletResponse response, String msgCode) throws IOException &#123; writeResponse(response, "0000", getMessage(msgCode)); &#125; public static void writeResponse(HttpServletResponse response, String statusCode, String msg) throws IOException &#123; JSONObject jsonObject = new JSONObject(); jsonObject.put("code", statusCode); jsonObject.put("msg", msg); response.setCharacterEncoding("utf-8"); response.setContentType("application/json; charset=utf-8"); PrintWriter writer = response.getWriter(); writer.write(jsonObject.toString()); &#125; public static String getMessage(String code) &#123; return messageSource.getMessage(code, null, null); &#125; @Autowired private void setMessageSource(MessageSource messageSource) &#123; SecurityHandlerUtil.messageSource = messageSource; &#125;&#125; authenticationEntryPointauthenticationEntryPoint方法指定了用户未登录时的入口点。由于用户尚未通过身份验证，因此需要返回一个响应，指示用户必须先进行身份验证。响应同样是根据请求类型决定，如果请求页面，将重定向到登录页；如果请求数据，将返回错误消息。 UnauthorizedEntryPoint123456789public class UnauthorizedEntryPoint implements AuthenticationEntryPoint &#123; protected final Logger LOGGER = LogManager.getLogger(getClass()); public static final String CREDENTIALS_EXPIRED = "credentialsExpired"; @Override public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException &#123; LOGGER.error("用户未登录", authException); SecurityHandlerUtil.handleAnyUnthorizedRequest(request, response, CREDENTIALS_EXPIRED); &#125;&#125; 自定义错误信息数据源错误信息数据源123456@Beanprotected ResourceLoaderAware messageSource() &#123; ReloadableResourceBundleMessageSource messageSource = new ReloadableResourceBundleMessageSource(); messageSource.setBasename("classpath:spring/security/messages"); return messageSource;&#125; 攻击保护配置同源访问同源访问12http.headers() .addHeaderWriter(new XFrameOptionsHeaderWriter(XFrameOptionsHeaderWriter.XFrameOptionsMode.SAMEORIGIN)); 防crsf防crsf1http.crsf(); session保护session保护12http.sessionManagement() .sessionFixation().migrateSession();]]></content>
      <categories>
        <category>学习笔记</category>
        <category>开发框架</category>
        <category>Spring</category>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven个性化打包说明]]></title>
    <url>%2Fmaven%E4%B8%AA%E6%80%A7%E5%8C%96%E6%89%93%E5%8C%85%E8%AF%B4%E6%98%8E.html</url>
    <content type="text"><![CDATA[以实际项目为例，介绍maven打包插件的使用，实现个性化打包。 工程目录结构miapp项目分为两个模块 yd-miapp模块为web项目 java代码部分其中，function目录下，存在不同中心的组件代码 静态资源部分其中，views目录下，存在不同中心的静态资源 目前war包目录结构目前war包中包含了全部的组件代码和静态资源，与工程目录结构类似。 独立打包war包目录结构比如，我们打包的是城市代码为00031400。独立打包时，只包含00031400城市的组件和静态资源。 注意，00000000和99999999是特殊的城市代码，d00000000存放的是公共资源，d99999999存放的是模板资源。 打包操作新建配置文件在yd-miapp/src/main/resources/filters目录下新建配置文件，配置文件命名规则是product-centerid.xml，比如product-00031400.xml、product-00055500.xml 编写配置项配置文件中的配置项请参考sample-db2、sample-mysql、sample-oracle 执行以下maven打包命令进入miapp目录下，执行以下maven命令。其中centerid是中心编码，比如00031400、0005550012mvn clean package -Dp=centeridmvn clean package -Dp=00031400 原理maven提供了一个打包插件，maven-war-plugin，负责收集Web应用程序的所有的依赖，类和资源，并将它们打包到war包中。 打包插件提供了一系列参数，通过配置这些参数，可以个性化输出的war包。 我们使用了以下参数来进行独立打包。 属性 类型 支持版本 描述 &lt;warSourceExcludes> String - 在编译周期完成后，向target目录复制文件时忽略的目录列表，用逗号分隔。使用表达式％regex []，可以使用正则表达式语法。 &lt;packagingExcludes> String 2.1-alpha-2 最终构建war包之前，从target目录抽取war包文件时忽略的目录列表，用逗号分隔。使用表达式％regex []，可以使用正则表达式语法。 我们在独立打包时，想要忽略的就是除当前城市以外的组件和资源文件，而且需要保留d00000000和d99999999目录。因此，使用如下表达式过滤资源。123%regex[WEB-INF/classes/function/d(?!(?:$&#123;p&#125;|00000000|99999999).+$).+],%regex[WEB-INF/views/assets/plugins/d(?!(?:$&#123;p&#125;|00000000|99999999).+$).+],%regex[WEB-INF/views/d(?!(?:$&#123;p&#125;|00000000|99999999).+$).+] 首先，在pom.xml中配置了maven-war-plugin1234567891011121314151617&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;webResources&gt; &lt;resource&gt; &lt;directory&gt;src/main/webapp&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;WEB-INF/web.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/webResources&gt; &lt;warSourceExcludes&gt;$&#123;packagingExcludes&#125;&lt;/warSourceExcludes&gt; &lt;packagingExcludes&gt;$&#123;packagingExcludes&#125;&lt;/packagingExcludes&gt; &lt;/configuration&gt;&lt;/plugin&gt; 然后在pom.xml中配置了一个生产环境使用的公共profile。123456789101112131415161718192021&lt;profile&gt; &lt;id&gt;product&lt;/id&gt; &lt;build&gt; &lt;filters&gt; &lt;filter&gt;$&#123;basedir&#125;/src/main/resources/filters/product-$&#123;p&#125;.properties&lt;/filter&gt; &lt;/filters&gt; &lt;/build&gt; &lt;properties&gt; &lt;packagingExcludes&gt; %regex[WEB-INF/classes/function/d(?!(?:$&#123;p&#125;|00000000|99999999).+$).+], %regex[WEB-INF/views/assets/plugins/d(?!(?:$&#123;p&#125;|00000000|99999999).+$).+], %regex[WEB-INF/views/d(?!(?:$&#123;p&#125;|00000000|99999999).+$).+] &lt;/packagingExcludes&gt; &lt;/properties&gt; &lt;activation&gt; &lt;property&gt; &lt;name&gt;p&lt;/name&gt; &lt;value&gt;&lt;/value&gt; &lt;/property&gt; &lt;/activation&gt;&lt;/profile&gt; 公共profile激活条件是，执行maven命令时，传入参数p（maven命令传参数的方式是：-D参数名=参数值，比如：-Dp=00031400）公共profile激活后，会使用product-centerid.properties进行参数初始化，根据资源过滤表达式进行打包，最终实现独立打包。 多中心打包war包目录结构我们可能还需要单独打包某几个中心的源码，比如建设云平台应用。 比如，我们想要打包的是中心为00031400、00055500。多中心打包时，只包含00031400、00055500城市的组件和静态资源。 注意，00000000和99999999是特殊的城市代码，d00000000存放的是公共资源，d99999999存放的是模板资源 打包操作新建配置文件在yd-miapp/src/main/resources/filters目录下新建配置文件，配置文件命名规则是product-centerid.xml。这里的centerid不再代表中心编码，仅起唯一标识的作用，可以任意命名，需保证易读性。比如product-yun.xml、product-jlcloud.xml 编写配置项配置文件中的配置项请参考sample-db2、sample-mysql、sample-oracle 配置多个中心码在配置文件product-centerid.xml中，新建一个配置项centerids12#centerids=centerid1|centerid2|...centerids=00031400|00055500 执行以下maven打包命令进入miapp目录下，执行以下maven命令。其中centerid是唯一标识，比如yun、jlcloud，与第1步中创建的配置文件后缀保持一致123mvn clean package -Dp=centeridmvn clean package -Dp=yunmvn clean package -Dp=jlcloud 原理我们依然使用了maven的打包插件。除打包插件外，还使用了属性插件，properties-maven-plugin，用于在maven项目生命周期的各个阶段进行资源过滤。 我们使用了read-project-properties来进行多中心打包。read-project-properties是属性插件提供的一个goal（可以理解为任务），可以读取属性文件，并将属性存储为项目属性，可作为在pom.xml中硬编码属性值的替代方法。尤其适合我们的需求，即在构建时，才指定属性占位符的来源。 我们在多中心打包时，想要忽略的就是除指定城市以外的组件和资源文件，而且需要保留d00000000和d99999999目录。因此，使用如下表达式过滤资源。123%regex[WEB-INF/classes/function/d(?!(?:$&#123;p&#125;|$&#123;centerids&#125;|00000000|99999999).+$).+],%regex[WEB-INF/views/assets/plugins/d(?!(?:$&#123;p&#125;|$&#123;centerids&#125;|00000000|99999999).+$).+],%regex[WEB-INF/views/d(?!(?:$&#123;p&#125;|$&#123;centerids&#125;|00000000|99999999).+$).+]表达式中的${centerids}是占位符，在打包时属性插件将使用filter文件中定义的centerids属性值，替换占位符。如果filter文件中没有定义centerids属性，那么将使用parent.properties中的属性值，替换占位符。 基于上文提到的独立打包配置，只需要在pom.xml中配置properties-maven-plugin123456789101112131415161718192021&lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;properties-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.0-alpha-2&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;initialize&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;read-project-properties&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;files&gt; &lt;file&gt;$&#123;basedir&#125;/src/main/resources/filters/parent.properties&lt;/file&gt; &lt;file&gt;$&#123;basedir&#125;/src/main/resources/filters/product-$&#123;p&#125;.properties&lt;/file&gt; &lt;/files&gt; &lt;quiet&gt;true&lt;/quiet&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>开发语言</category>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>war</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git之SSHKey使用]]></title>
    <url>%2Fgit%E4%B9%8Bsshkey%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[SSH key作用使用SSH Key可以免密登录ssh服务器，在我们日常使用git的时候，一般会使用SSH Key。 使用SSH Key的步骤生成SSH Key打开命令行工具，输入如下命令12345678910111213141516171819202122232425262728ssh-keygen -t rsa -C "Linn"-- 提示如下内容，如果使用默认文件，直接敲回车。或者输入指定文件路径后，敲回车。-- 请输入保存密钥的文件名，不输入的情况，将默认使用~/.ssh/id_rsaGenerating public/private rsa key pair.Enter file in which to save the key (~/.ssh/id_rsa):-- 提示如下内容，如果不设置密码，直接敲回车。或者输入密码后，敲回车。-- 输入密码，不输入表示无密码Enter passphrase (empty for no passphrase):-- 提示如下内容，如果不设置密码，直接敲回车。或者输入相同密码后，敲回车。-- 再次输入密码Enter same passphrase again:-- 提示如下内容，密钥生成成功。密钥生成的位置是~/.ssh，其中Linn是私钥，Linn.pub是公钥。Your identification has been saved in Linn.Your public key has been saved in Linn.pub.The key fingerprint is:SHA256:/Rc6E9x+bExy8rHYkenvIudnWXGZ097JunbOO16xcwY LinnThe key's randomart image is:+---[RSA 2048]----+| E++|| . . .=|| . o . . + || +.+.+.* || S=.*o@=+o|| o.B+XX+|| .=*o+*|| o+.o || |+----[SHA256]-----+ 添加SSH Key到ssh-agent执行ssh-add命令1ssh-add Linn添加成功1Identity added: Linn (Linn)如果出现如下提示，说明ssh-agent服务未启动，需要先启动服务，再执行ssh-add命令1Could not open a connection to your authentication agent.启动ssh-agent服务1ssh-agent bash 登录Github或其他Git后台，添加公钥测试1ssh git@github.com 配置成功123PTY allocation request failed on channel 0Hi xxx! You've successfully authenticated, but GitHub does not provide shell access.Connection to github.com closed. 关于SSH agent如果您的私钥使用密码短语来加密了的话，每一次使用 SSH 密钥对进行登录的时候，您都必须输入正确的密码短语。而 SSH agent 程序能够将您的已解密的私钥缓存起来，在需要的时候提供给您的 SSH 客户端。这样子，您就只需要将私钥加入 SSH agent 缓存的时候输入一次密码短语就可以了。这为您经常使用 SSH 连接提供了不少便利。SSH agent 一般会设置成在登录会话的时候自动启动，并在整个会话中保持运行。有不少的 SSH agent 供您选择，我们将为您介绍几种常用的 SSH agent，您可以根据您的需要进行选择。 wikiSSH agents]]></content>
      <categories>
        <category>学习笔记</category>
        <category>开发语言</category>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>ssh key</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebSphere更新jsp和web.xml]]></title>
    <url>%2Fwebsphere%E6%9B%B4%E6%96%B0jsp%E5%92%8Cweb-xml.html</url>
    <content type="text"><![CDATA[WebShphere更新应用在WebSphere下部署应用时，更新任何文件都应该通过控制台更新的方式去更新。而且在集群部署的情况下，通过控制台更新可以将更新文件同步到所有节点上。 在某些特殊情况下，需要手动更新。这时，就需要我们手动删除缓存，同步相关文件。如果是集群部署，还需要将更新文件手动同步到所有节点上。这里介绍一下手动更新jsp和web.xml的方法。 WebSphere手动更新应用方法手动更新jsp 将jsp文件上传到was服务器上。 删除缓存目录下，jsp编译后生成的class文件jsp缓存目录1&#123;was_home&#125;\AppServer\profiles\AppSrv01\temp 手动更新web.xml 将web.xml上传到was服务器上. 将更新内容同步到web_merged.xml文件中 同步缓存web.xml缓存目录1config\cells\&lt;cell_name&gt;\applications\&lt;ear_name&gt;\deployments\&lt;app_name&gt;\&lt;war_name&gt;\WEB-INF]]></content>
      <categories>
        <category>学习笔记</category>
        <category>部署相关</category>
        <category>WebSphere</category>
      </categories>
      <tags>
        <tag>websphere</tag>
        <tag>was</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebSphere下log4j2自定义插件未加载的解决办法]]></title>
    <url>%2Fwebsphere%E4%B8%8Blog4j2%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6%E6%9C%AA%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html</url>
    <content type="text"><![CDATA[jar包冲突解决方案之前，我们采用引用共享库的方式，解决了WebSphere自带jar包与项目下log4j2相关的jar包冲突的问题。WebSphere自带jar包与应用jar包冲突的解决办法 问题现象解决了jar包冲突的问题后，顺利启动工程。启动后发现，log4j2没有加载自定义插件。 log4j2插件机制在log4j的官网上，我查到了如下介绍（可以跳过这段英文介绍，后面有翻译）：In Log4j 2 a plugin is declared by adding a @Plugin annotation to the class declaration. During initialization the Configuration will invoke the PluginManager to load the built-in Log4j plugins as well as any custom plugins. The PluginManager locates plugins by looking in five places: Serialized plugin listing files on the classpath. These files are generated automatically during the build (more details below). (OSGi only) Serialized plugin listing files in each active OSGi bundle. A BundleListener is added on activation to continue checking new bundles after log4j-core has started. A comma-separated list of packages specified by the log4j.plugin.packages system property. Packages passed to the static PluginManager.addPackages method (before Log4j configuration occurs). The packages declared in your log4j2 configuration file. Apache Log4j 2插件介绍 大意就是，log4j2支持插件机制，在启动阶段，PluginManager不仅会加载内建插件，也会加载自定义插件。PluginManager会在5个位置查找插件。 我们采用的是，在配置文件中定义插件扫描包位置，自定义插件放在扫描包下。再看官方对插件扫描包位置配置项的说明（只截取部分）：The configuration element in the XML file accepts several attributes: Attribute Name Description packages A comma separated list of package names to search for plugins. Plugins are only loaded once per classloader so changing this value may not have any effect upon reconfiguration. Apache Log4j 2配置项说明注意看我标注的这句话，每个类加载器只加载一次插件。 问题原因之前在我们在建立共享库的时候，勾选了【请对此共享库使用隔离的类装入器】，此时共享库将使用独立的类加载器，而我们的自定义插件没有放在共享库中，自然扫描不到。 解决方案解决办法是，在共享库的配置中，取消勾选【请对此共享库使用隔离的类装入器】。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>部署相关</category>
        <category>WebSphere</category>
      </categories>
      <tags>
        <tag>websphere</tag>
        <tag>was</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebSphere自带jar包与应用jar包冲突的解决办法]]></title>
    <url>%2Fwebsphere%E8%87%AA%E5%B8%A6jar%E5%8C%85%E4%B8%8E%E5%BA%94%E7%94%A8jar%E5%8C%85%E5%86%B2%E7%AA%81%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html</url>
    <content type="text"><![CDATA[问题现象在WebSphere8.5下安装我们的应用，一直提示NullPointerException，然而在Tomcat、Weblogic下都没有该问题。 分析错误日志，发现报错信息与log4j有关，而我们也确实使用了log4j，版本是2.10.0。 尝试解决尝试着将log4j的jar包和slf4j的jar包从war包中删除，再安装，就启动成功了。此时再手动将之前移除的jar包放到应用的lib路径下，日志也可以正常打印了。 原因原因可能是我们所使用的log4j、slf4j的jar包，websphere8.5本身提供，而且自带的jar包与我们使用的版本不一致。在默认情况下，容器会优先加载自带的jar包，从而导致应用启动失败，提示NullPointerException。 解决方案 新建共享库文件夹在应用服务器上，新建共享库文件夹，将你希望优先加载的jar包放在该路径下。如果是集群部署，需要在所有集群服务器上，都建立这样的文件夹，路径需要保持一致。 在控制台中，新建共享库点击左侧菜单【环境-&gt;共享库】点击【新建】按钮。类路径填写在上一步中新建的共享库文件夹路径 在已安装的应用中，引入共享库进入应用的配置界面，点击【共享库引用】选择应用程序或模块，点击【引用共享库】按钮选择需要引用的共享库 安装应用过程中，引入共享库选择详细安装在【步骤 4: 映射共享库】中，引入共享库]]></content>
      <categories>
        <category>学习笔记</category>
        <category>部署相关</category>
        <category>WebSphere</category>
      </categories>
      <tags>
        <tag>websphere</tag>
        <tag>was</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intellij IDEA 远程调试Tomcat下的应用]]></title>
    <url>%2Fintellij-idea-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95tomcat%E4%B8%8B%E7%9A%84%E5%BA%94%E7%94%A8.html</url>
    <content type="text"><![CDATA[配置Tomcat远程调试端口在Tomcat的bin目录下找到catalina.bat，搜索JPDA_ADDRESS，即为远程调试监听端口，默认为8000 1set JPDA_ADDRESS = 8000 cd到bin目录下，运行catalina.bat，并开启远程调试功能1catalina.bat jpda start 在intellij中，新建远程服务器 配置远程服务的ip和端口 配置远程调试监听端口 在intellij中启动即可]]></content>
      <categories>
        <category>学习笔记</category>
        <category>开发语言</category>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>intellij idea</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web容器默认servlet]]></title>
    <url>%2Fweb%E5%AE%B9%E5%99%A8%E9%BB%98%E8%AE%A4servlet.html</url>
    <content type="text"><![CDATA[常见中间件默认servlet 默认servlet-name 容器 default Tomcat Jetty JBoss GlassFish _ah_default Google App Engine resin-file Resin FileServlet WebLogic SimpleFileServlet WebSphere 在spring项目中使用默认servlet在spring配置文件中开启如下配置，即可开启默认servlet1&lt;mvc:default-servlet-handler/&gt;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>开发语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>web container</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#中程序集版本名词解释]]></title>
    <url>%2Fc-%E4%B8%AD%E7%A8%8B%E5%BA%8F%E9%9B%86%E7%89%88%E6%9C%AC%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A.html</url>
    <content type="text"><![CDATA[微软内部开发有一个版本号命名规则，格式如下: Major Minor Build Revision 主要版本号 次要版本号 生成号 修订号 eg：2.23.159.23 版本号各部分解释Major名称相同但主要版本号不同的程序集不可互换。 更高版本号可能表明大幅重写无法假定向后兼容的产品。 Minor如果两个程序集的名称和主要版本号相同，而次要版本号不同，这指示显著增强，但照顾到了向后兼容性。 该较高的次要版本号可指示产品的修正版或完全向后兼容的新版本。 Build生成号的不同表示对相同源所作的重新编译。 处理器、 平台或编译器更改时，可能使用不同的生成号。 Revision名称、主要版本号和次要版本号都相同但修订号不同的程序集应是完全可互换的。 更高修订号可能在修复以前发布的程序集安全漏洞的版本中使用。 程序集相关信息（AssemblyInfo)AssemblyVersion（程序集版本）在.NET Framework中编译和运行时使用的版本号，使用该版本号定位和加载指定程序集。当你在你的项目中引用了指定的程序集，其版本号将会嵌入到你的项目中。在运行时，CLR通过该版本号加载指定程序集。注意，仅当程序集使用强命名时，才会使用程序集名称、公钥、语言信息以及该版本号查找指定程序集，否则只会根据文件名进行查找。 AssemblyFileVersion（文件版本）在文件系统中给文件的版本号，会在Windows资源管理器中显示。但是，在.NET Framework引用类库时从来不会用到这个版本。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>开发语言</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#调用ocx的方法]]></title>
    <url>%2Fc-%E8%B0%83%E7%94%A8ocx%E7%9A%84%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[Winform工程中调用ocx在项目中添加对ocx的引用将ocx文件拖拽至工具箱将ocx控件从工具箱中拖拽到窗体上 类库工程中调用ocx编译ocx文件打开Visual Studio命令提示符输入命令aximp xxx.ocx，生成两个dll文件 将两个dll文件放到项目路径下在项目中添加引用，引用Ax开头的dll调用ocx控件的方法123Ocx ocx = new Ocx();ocx.CreateControl();ocx.method();]]></content>
      <categories>
        <category>学习笔记</category>
        <category>开发语言</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>ocx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebSphere下免密登录]]></title>
    <url>%2Fwebsphere%E4%B8%8B%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95.html</url>
    <content type="text"><![CDATA[取消控制台认证在was node的安装目录下，查找安全文件security.xml1$WAS_Profile_HOME\config\cells 在xml中，查找第一个enabled属性，将其修改为false，再重新启动即可]]></content>
      <categories>
        <category>学习笔记</category>
        <category>部署相关</category>
        <category>WebSphere</category>
      </categories>
      <tags>
        <tag>websphere</tag>
        <tag>was</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebSphere下配置servlet可访问WEB-INF]]></title>
    <url>%2Fwebsphere%E4%B8%8B%E9%85%8D%E7%BD%AEservlet%E5%8F%AF%E8%AE%BF%E9%97%AEweb-inf.html</url>
    <content type="text"><![CDATA[WebSphere的WebContainer配置项说明WebSphere的WebContainer配置项中： Attributename Data type Default value Description exposeWebInfOnDispatch boolean false If true, a servlet can access files in the WEB-INF directory. If false (default), a servlet cannot access files the WEB-INF directory. exposeWebInfOnDispatch属性默认值为false，servlet不能访问WEB-INF目录。 配置示例按照下图配置，可访问WEB-INF目录]]></content>
      <categories>
        <category>学习笔记</category>
        <category>部署相关</category>
        <category>WebSphere</category>
      </categories>
      <tags>
        <tag>websphere</tag>
        <tag>was</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL在Windows环境下安装]]></title>
    <url>%2Fmysql%E5%9C%A8windows%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85.html</url>
    <content type="text"><![CDATA[下载官方安装包MySQL 解压到本地目录新建my.ini12345678910my.ini[mysql]default-character-set=utf8[mysqld]basedir =d:\DataBase\MySql\mysql-5.7.16-winx64datadir =d:\DataBase\MySql\mysql-5.7.16-winx64\dataport =3306character-set-server=utf8[client]default-character-set=utf8 cd到bin目录下初始化数据，执行命令123mysqld --initialize-- 据说执行这句话可以免密陆mysqld --initialize-insecure --user=mysql 注册windows服务1mysqld --install MySQL --defaultsfile="d:\DataBase\MySql\mysql-5.7.16-winx64\my.ini" 启动mysql服务1net start mysql 登陆mysql1mysql -u root -p 提示输入密码，初始无密码，直接回车切换数据库1use mysql 修改密码1update user set password = password('newpsw') where user = 'root'; 刷新权限表1flush privileges; 修改主机名，允许所有ip连接1update user set hosts = '%' where user = 'root'; 退出mysql1exit 如需关闭服务1net stop mysql 注意5.7版本之后，初始化数据后，会自动分配一个密码，密码可在一个.err文件中查看日志获取在my.ini中配置一项可以不使用密码登陆，在[mysqld]下输入skip-grant-tables]]></content>
      <categories>
        <category>学习笔记</category>
        <category>部署相关</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL官方Docker镜像使用]]></title>
    <url>%2Fmysql%E5%AE%98%E6%96%B9docker%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[启动mysql服务实例拉取镜像12docker pull mysqldocker pull mysql:5.7 启动实例1docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=password -d mysql:5.7 测试mysql服务实例安装mysql客户端 1apt-get install mysql-client-core-5.7 登录mysql1mysql -h127.0.0.1 -P3306 -uroot -ppassword 使用自定义MySQL配置文件默认情况下，MySQL的启动配置文件是/etc/mysql/my.cnf，引用了/etc/mysql/conf.d和/etc/mysql/mysql.conf.d文件夹想要使用自定义配置文件，可将配置文件挂载到mysql容器的/etc/mysql/conf.d和/etc/mysql/mysql.conf.d目录下1docker run --name mysql -p 3307:3306 -v /mnt/share/custom.cnf:/etc/mysql/conf.d/custom.cnf -e MYSQL_ROOT_PASSWORD=password -d mysql:5.7 使用自定义MySQL配置使用命令行参数来指定配置1docker run --name mysql -p 3307:3306 -v /mnt/share/custom.cnf:/etc/mysql/conf.d/custom.cnf -e MYSQL_ROOT_PASSWORD=password -d mysql:5.7 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci --lower_case_table_names=1 查看可配参数1docker run -it --rm mysql:tag --verbose --hel]]></content>
      <categories>
        <category>学习笔记</category>
        <category>部署相关</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>docker</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker中国官方镜像加速]]></title>
    <url>%2Fdocker%E4%B8%AD%E5%9B%BD%E5%AE%98%E6%96%B9%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F.html</url>
    <content type="text"><![CDATA[Docker中国官方镜像加速 编辑配置文件，配置镜像地址12345vi /etc/docker/daemon.json&#123; "registry-mirrors": ["https://registry.docker-cn.com"]&#125;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>部署相关</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>docker hub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下war包操作]]></title>
    <url>%2Flinux%E4%B8%8Bwar%E5%8C%85%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[Unzip1unzip -oq common.war -d common jar1jar -xvf game.war]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Linux</category>
        <category>通用</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>war</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下端口进程互查]]></title>
    <url>%2Flinux%E4%B8%8B%E7%AB%AF%E5%8F%A3%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%9F%A5.html</url>
    <content type="text"><![CDATA[先查看进程pid1ps -ef |grep 进程名 通过pid查看占用端口1netstat -nap |grep 进程id 通过端口查看进程1netstat -nap |grep 端口号]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Linux</category>
        <category>通用</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机Virtual Box环境下Ubuntu初始化配置网卡]]></title>
    <url>%2F%E8%99%9A%E6%8B%9F%E6%9C%BAvirtual-box%E7%8E%AF%E5%A2%83%E4%B8%8Bubuntu%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE%E7%BD%91%E5%8D%A1.html</url>
    <content type="text"><![CDATA[配置网卡为桥接模式 配置虚拟机ip、网关与宿主机在同一网段 断开再连接]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Linux</category>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>virtualbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机Virtual Box环境下Ubuntu初始化配置共享文件夹]]></title>
    <url>%2F%E8%99%9A%E6%8B%9F%E6%9C%BAvirtual-box%E7%8E%AF%E5%A2%83%E4%B8%8Bubuntu%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9.html</url>
    <content type="text"><![CDATA[虚拟机安装增强功能 宿主机任意位置创建一个文件夹，用于宿主机与虚拟机交换文件 创建共享文件夹，选择在步骤2中创建的文件夹路径 虚拟机mnt文件夹下创建一个文件夹，用于虚拟机与宿主机交换文件12cd /mntmkdir share 建立共享文件夹映射12cd /mntsudo mount -t vboxsf ShareSwap share]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Linux</category>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>virtualbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu离线安装软件包]]></title>
    <url>%2Fubuntu%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%8C%85.html</url>
    <content type="text"><![CDATA[Ubuntu软件包格式为deb离线安装命令1sudo dpkg -i xxx.deb 使用apt-get命令安装软件时，所有下载的deb包都缓存到了/var/cache/apt/archives目录下]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Linux</category>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>deb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu开启SSH服务]]></title>
    <url>%2Fubuntu%E5%BC%80%E5%90%AFssh%E6%9C%8D%E5%8A%A1.html</url>
    <content type="text"><![CDATA[安装ssh服务1apt-get install openssh-server 开启ssh服务1service ssh start ssh配置文件1vi /etc/ssh/sshd_config]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Linux</category>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ssh</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS防火墙使用]]></title>
    <url>%2Fcentos%E9%98%B2%E7%81%AB%E5%A2%99%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[启动防火墙查看防火墙是否启动1systemctl status firewalld如果没有启动，启动1systemctl start firewalld 开放端口命令 12firewall-cmd --zone=public --add-port=1. 1. /tcp --permanentsystemctl restart firewalld 关闭端口命令12firewall-cmd --zone=public --remove-port=1. 1. /tcp -permanentsystemctl restart firewalld 查看开放端口命令1firewall-cmd --zone=public --list-ports]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Linux</category>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>firewall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机VMware环境下CentOS初始化配置网卡]]></title>
    <url>%2F%E8%99%9A%E6%8B%9F%E6%9C%BAvmware%E7%8E%AF%E5%A2%83%E4%B8%8Bcentos%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE%E7%BD%91%E5%8D%A1.html</url>
    <content type="text"><![CDATA[检测网卡1ipconfig 发现只有ens33和lo两个网卡，需要将ens33修改为eth0 修改网卡名称将其中的NAME和DEVICE项修改为eth01vi /etc/sysconfig/network-scripts/ifcfg-ens33 修改配置文件名称1mv /etc/sysconfig/network-scripts/ifcfg-ens33 /etc/sysconfig/network-scripts/ifcfg-eth0 编辑/etc/default/grub配置文件加入net.ifnames=0 biosdevname=0到GRUBCMDLINELINUX变量12345678vi /etc/default/grubGRUB_TIMEOUT=5GRUB_DISTRIBUTOR="$(sed 's, release .*$,,g' /etc/system-release)"GRUB_DEFAULT=savedGRUB_DISABLE_SUBMENU=trueGRUB_TERMINAL_OUTPUT="console"GRUB_CMDLINE_LINUX="crashkernel=auto net.ifnames=0 biosdevname=0 rhgb quiet"GRUB_DISABLE_RECOVERY="true" 重新生成GRUB配置并更新内核参数运行命令grub2-mkconfig -o /boot/grub2/grub.cfg1grub2-mkconfig -o /boot/grub2/grub.cfg 重启OS1reboot 检测网卡以验证1ifconfig]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Linux</category>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>vmware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS开启SSH服务]]></title>
    <url>%2Fcentos%E5%BC%80%E5%90%AFssh%E6%9C%8D%E5%8A%A1.html</url>
    <content type="text"><![CDATA[安装openssh-server1yum list installed |grep openssh-server 如果有输出，证明已经安装了openssh-server，如果没有，需要安装1yum install openssh-server 修改sshd服务配置文件编辑sshd服务配置文件1vi /etc/ssh/sshd_config 开启监听123Port 22ListenAddress 0.0.0.0ListenAddress :: 允许远程登录1PermitRootLogin yes 使用用户名密码作为连接验证1PasswordAuthentication yes 开启sshd服务1service sshd start 配置开机自启动1systemctl enable sshd]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Linux</category>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
</search>
